// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rulesets.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CountRulesetsByStatus = `-- name: CountRulesetsByStatus :many
SELECT status, COUNT(*) as count
FROM rulesets 
WHERE environment = $1
GROUP BY status
`

type CountRulesetsByStatusRow struct {
	Status RulesetStatus `db:"status" json:"status"`
	Count  int64         `db:"count" json:"count"`
}

func (q *Queries) CountRulesetsByStatus(ctx context.Context, environment string) ([]*CountRulesetsByStatusRow, error) {
	rows, err := q.db.Query(ctx, CountRulesetsByStatus, environment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CountRulesetsByStatusRow{}
	for rows.Next() {
		var i CountRulesetsByStatusRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CreateRuleset = `-- name: CreateRuleset :one

INSERT INTO rulesets (
    name, version, environment, status, ruleset_data, rule_count,
    description, tags, owner, team, metadata,
    git_commit, git_branch, git_tag, git_author, pull_request,
    compiled_at, compiler_version, schema_version, validation_hash,
    created_by, updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16,
    $17, $18, $19, $20,
    $21, $22
) RETURNING id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by
`

// Ruleset queries for sqlc code generation
func (q *Queries) CreateRuleset(ctx context.Context, name string, version string, environment string, status RulesetStatus, rulesetData json.RawMessage, ruleCount int32, description pgtype.Text, tags []string, owner pgtype.Text, team pgtype.Text, metadata json.RawMessage, gitCommit pgtype.Text, gitBranch pgtype.Text, gitTag pgtype.Text, gitAuthor pgtype.Text, pullRequest pgtype.Text, compiledAt pgtype.Timestamptz, compilerVersion pgtype.Text, schemaVersion pgtype.Text, validationHash pgtype.Text, createdBy pgtype.Text, updatedBy pgtype.Text) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, CreateRuleset,
		name,
		version,
		environment,
		status,
		rulesetData,
		ruleCount,
		description,
		tags,
		owner,
		team,
		metadata,
		gitCommit,
		gitBranch,
		gitTag,
		gitAuthor,
		pullRequest,
		compiledAt,
		compilerVersion,
		schemaVersion,
		validationHash,
		createdBy,
		updatedBy,
	)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const DeleteRuleset = `-- name: DeleteRuleset :exec
DELETE FROM rulesets 
WHERE id = $1
`

func (q *Queries) DeleteRuleset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteRuleset, id)
	return err
}

const GetLatestRuleset = `-- name: GetLatestRuleset :one
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE name = $1 AND environment = $2
ORDER BY created_at DESC 
LIMIT 1
`

func (q *Queries) GetLatestRuleset(ctx context.Context, name string, environment string) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, GetLatestRuleset, name, environment)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const GetRecentRulesets = `-- name: GetRecentRulesets :many
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE created_at >= $1
ORDER BY created_at DESC
LIMIT $2
`

func (q *Queries) GetRecentRulesets(ctx context.Context, createdAt pgtype.Timestamptz, limit int32) ([]*Ruleset, error) {
	rows, err := q.db.Query(ctx, GetRecentRulesets, createdAt, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Ruleset{}
	for rows.Next() {
		var i Ruleset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRuleset = `-- name: GetRuleset :one
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE name = $1 AND version = $2 AND environment = $3
`

func (q *Queries) GetRuleset(ctx context.Context, name string, version string, environment string) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, GetRuleset, name, version, environment)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const GetRulesetByID = `-- name: GetRulesetByID :one
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE id = $1
`

func (q *Queries) GetRulesetByID(ctx context.Context, id uuid.UUID) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, GetRulesetByID, id)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const GetRulesetStats = `-- name: GetRulesetStats :one
SELECT 
    COUNT(*) as total_rulesets,
    COUNT(*) FILTER (WHERE status = 'deployed') as deployed_rulesets,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_rulesets,
    COUNT(DISTINCT name) as unique_rulesets,
    COUNT(DISTINCT environment) as total_environments
FROM rulesets
`

type GetRulesetStatsRow struct {
	TotalRulesets     int64 `db:"total_rulesets" json:"total_rulesets"`
	DeployedRulesets  int64 `db:"deployed_rulesets" json:"deployed_rulesets"`
	FailedRulesets    int64 `db:"failed_rulesets" json:"failed_rulesets"`
	UniqueRulesets    int64 `db:"unique_rulesets" json:"unique_rulesets"`
	TotalEnvironments int64 `db:"total_environments" json:"total_environments"`
}

func (q *Queries) GetRulesetStats(ctx context.Context) (*GetRulesetStatsRow, error) {
	row := q.db.QueryRow(ctx, GetRulesetStats)
	var i GetRulesetStatsRow
	err := row.Scan(
		&i.TotalRulesets,
		&i.DeployedRulesets,
		&i.FailedRulesets,
		&i.UniqueRulesets,
		&i.TotalEnvironments,
	)
	return &i, err
}

const GetRulesetVersions = `-- name: GetRulesetVersions :many
SELECT r.version, r.created_at, r.created_by, r.git_commit, r.status,
       EXISTS(SELECT 1 FROM deployments d WHERE d.ruleset_id = r.id AND d.status = 'active') as is_deployed
FROM rulesets r
WHERE r.name = $1 AND r.environment = $2
ORDER BY r.created_at DESC
`

type GetRulesetVersionsRow struct {
	Version    string             `db:"version" json:"version"`
	CreatedAt  pgtype.Timestamptz `db:"created_at" json:"created_at"`
	CreatedBy  pgtype.Text        `db:"created_by" json:"created_by"`
	GitCommit  pgtype.Text        `db:"git_commit" json:"git_commit"`
	Status     RulesetStatus      `db:"status" json:"status"`
	IsDeployed bool               `db:"is_deployed" json:"is_deployed"`
}

func (q *Queries) GetRulesetVersions(ctx context.Context, name string, environment string) ([]*GetRulesetVersionsRow, error) {
	rows, err := q.db.Query(ctx, GetRulesetVersions, name, environment)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRulesetVersionsRow{}
	for rows.Next() {
		var i GetRulesetVersionsRow
		if err := rows.Scan(
			&i.Version,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.GitCommit,
			&i.Status,
			&i.IsDeployed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRulesetsByGitCommit = `-- name: GetRulesetsByGitCommit :many
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE git_commit = $1
ORDER BY created_at DESC
`

func (q *Queries) GetRulesetsByGitCommit(ctx context.Context, gitCommit pgtype.Text) ([]*Ruleset, error) {
	rows, err := q.db.Query(ctx, GetRulesetsByGitCommit, gitCommit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Ruleset{}
	for rows.Next() {
		var i Ruleset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRulesetsByTags = `-- name: GetRulesetsByTags :many
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE tags && $1::text[] AND environment = $2
ORDER BY created_at DESC
LIMIT $3
`

func (q *Queries) GetRulesetsByTags(ctx context.Context, column1 []string, environment string, limit int32) ([]*Ruleset, error) {
	rows, err := q.db.Query(ctx, GetRulesetsByTags, column1, environment, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Ruleset{}
	for rows.Next() {
		var i Ruleset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRulesetsByTeam = `-- name: GetRulesetsByTeam :many
SELECT id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by FROM rulesets 
WHERE team = $1 AND environment = $2
ORDER BY created_at DESC
LIMIT $3
`

func (q *Queries) GetRulesetsByTeam(ctx context.Context, team pgtype.Text, environment string, limit int32) ([]*Ruleset, error) {
	rows, err := q.db.Query(ctx, GetRulesetsByTeam, team, environment, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Ruleset{}
	for rows.Next() {
		var i Ruleset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRulesets = `-- name: ListRulesets :many
SELECT r.id, r.name, r.version, r.environment, r.status, r.ruleset_data, r.rule_count, r.description, r.tags, r.owner, r.team, r.metadata, r.git_commit, r.git_branch, r.git_tag, r.git_author, r.pull_request, r.compiled_at, r.compiler_version, r.schema_version, r.validation_hash, r.created_at, r.updated_at, r.created_by, r.updated_by, 
       COALESCE(d.status, 'inactive') as deployment_status,
       d.deployed_at as last_deployed_at
FROM rulesets r
LEFT JOIN deployments d ON r.id = d.ruleset_id AND d.environment = r.environment
WHERE 
    ($1::text IS NULL OR r.name = ANY($1::text[]))
    AND ($2::text[] IS NULL OR r.environment = ANY($2::text[]))
    AND ($3::ruleset_status[] IS NULL OR r.status = ANY($3::ruleset_status[]))
    AND ($4::text IS NULL OR r.owner = $4)
    AND ($5::text IS NULL OR r.team = $5)
    AND ($6::text[] IS NULL OR r.tags && $6::text[])
    AND ($7::timestamptz IS NULL OR r.created_at >= $7)
    AND ($8::text IS NULL OR r.created_by = $8)
    AND ($9::text IS NULL OR r.git_commit = $9)
ORDER BY r.created_at DESC
LIMIT $10
`

type ListRulesetsRow struct {
	ID               uuid.UUID          `db:"id" json:"id"`
	Name             string             `db:"name" json:"name"`
	Version          string             `db:"version" json:"version"`
	Environment      string             `db:"environment" json:"environment"`
	Status           RulesetStatus      `db:"status" json:"status"`
	RulesetData      json.RawMessage    `db:"ruleset_data" json:"ruleset_data"`
	RuleCount        int32              `db:"rule_count" json:"rule_count"`
	Description      pgtype.Text        `db:"description" json:"description"`
	Tags             []string           `db:"tags" json:"tags"`
	Owner            pgtype.Text        `db:"owner" json:"owner"`
	Team             pgtype.Text        `db:"team" json:"team"`
	Metadata         json.RawMessage    `db:"metadata" json:"metadata"`
	GitCommit        pgtype.Text        `db:"git_commit" json:"git_commit"`
	GitBranch        pgtype.Text        `db:"git_branch" json:"git_branch"`
	GitTag           pgtype.Text        `db:"git_tag" json:"git_tag"`
	GitAuthor        pgtype.Text        `db:"git_author" json:"git_author"`
	PullRequest      pgtype.Text        `db:"pull_request" json:"pull_request"`
	CompiledAt       pgtype.Timestamptz `db:"compiled_at" json:"compiled_at"`
	CompilerVersion  pgtype.Text        `db:"compiler_version" json:"compiler_version"`
	SchemaVersion    pgtype.Text        `db:"schema_version" json:"schema_version"`
	ValidationHash   pgtype.Text        `db:"validation_hash" json:"validation_hash"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	CreatedBy        pgtype.Text        `db:"created_by" json:"created_by"`
	UpdatedBy        pgtype.Text        `db:"updated_by" json:"updated_by"`
	DeploymentStatus DeploymentStatus   `db:"deployment_status" json:"deployment_status"`
	LastDeployedAt   pgtype.Timestamptz `db:"last_deployed_at" json:"last_deployed_at"`
}

func (q *Queries) ListRulesets(ctx context.Context, column1 string, column2 []string, column3 []RulesetStatus, column4 string, column5 string, column6 []string, column7 pgtype.Timestamptz, column8 string, column9 string, limit int32) ([]*ListRulesetsRow, error) {
	rows, err := q.db.Query(ctx, ListRulesets,
		column1,
		column2,
		column3,
		column4,
		column5,
		column6,
		column7,
		column8,
		column9,
		limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListRulesetsRow{}
	for rows.Next() {
		var i ListRulesetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeploymentStatus,
			&i.LastDeployedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchRulesets = `-- name: SearchRulesets :many
SELECT r.id, r.name, r.version, r.environment, r.status, r.ruleset_data, r.rule_count, r.description, r.tags, r.owner, r.team, r.metadata, r.git_commit, r.git_branch, r.git_tag, r.git_author, r.pull_request, r.compiled_at, r.compiler_version, r.schema_version, r.validation_hash, r.created_at, r.updated_at, r.created_by, r.updated_by, 
       ts_rank(to_tsvector('english', r.name || ' ' || COALESCE(r.description, '')), plainto_tsquery($1)) as rank
FROM rulesets r
WHERE to_tsvector('english', r.name || ' ' || COALESCE(r.description, '')) @@ plainto_tsquery($1)
ORDER BY rank DESC, r.created_at DESC
LIMIT $2
`

type SearchRulesetsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Name            string             `db:"name" json:"name"`
	Version         string             `db:"version" json:"version"`
	Environment     string             `db:"environment" json:"environment"`
	Status          RulesetStatus      `db:"status" json:"status"`
	RulesetData     json.RawMessage    `db:"ruleset_data" json:"ruleset_data"`
	RuleCount       int32              `db:"rule_count" json:"rule_count"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Owner           pgtype.Text        `db:"owner" json:"owner"`
	Team            pgtype.Text        `db:"team" json:"team"`
	Metadata        json.RawMessage    `db:"metadata" json:"metadata"`
	GitCommit       pgtype.Text        `db:"git_commit" json:"git_commit"`
	GitBranch       pgtype.Text        `db:"git_branch" json:"git_branch"`
	GitTag          pgtype.Text        `db:"git_tag" json:"git_tag"`
	GitAuthor       pgtype.Text        `db:"git_author" json:"git_author"`
	PullRequest     pgtype.Text        `db:"pull_request" json:"pull_request"`
	CompiledAt      pgtype.Timestamptz `db:"compiled_at" json:"compiled_at"`
	CompilerVersion pgtype.Text        `db:"compiler_version" json:"compiler_version"`
	SchemaVersion   pgtype.Text        `db:"schema_version" json:"schema_version"`
	ValidationHash  pgtype.Text        `db:"validation_hash" json:"validation_hash"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	CreatedBy       pgtype.Text        `db:"created_by" json:"created_by"`
	UpdatedBy       pgtype.Text        `db:"updated_by" json:"updated_by"`
	Rank            float32            `db:"rank" json:"rank"`
}

func (q *Queries) SearchRulesets(ctx context.Context, plaintoTsquery string, limit int32) ([]*SearchRulesetsRow, error) {
	rows, err := q.db.Query(ctx, SearchRulesets, plaintoTsquery, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchRulesetsRow{}
	for rows.Next() {
		var i SearchRulesetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Version,
			&i.Environment,
			&i.Status,
			&i.RulesetData,
			&i.RuleCount,
			&i.Description,
			&i.Tags,
			&i.Owner,
			&i.Team,
			&i.Metadata,
			&i.GitCommit,
			&i.GitBranch,
			&i.GitTag,
			&i.GitAuthor,
			&i.PullRequest,
			&i.CompiledAt,
			&i.CompilerVersion,
			&i.SchemaVersion,
			&i.ValidationHash,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateRuleset = `-- name: UpdateRuleset :one
UPDATE rulesets 
SET 
    status = COALESCE($2, status),
    ruleset_data = COALESCE($3, ruleset_data),
    rule_count = COALESCE($4, rule_count),
    description = COALESCE($5, description),
    tags = COALESCE($6, tags),
    metadata = COALESCE($7, metadata),
    updated_by = $8,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by
`

func (q *Queries) UpdateRuleset(ctx context.Context, iD uuid.UUID, status RulesetStatus, rulesetData json.RawMessage, ruleCount int32, description pgtype.Text, tags []string, metadata json.RawMessage, updatedBy pgtype.Text) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, UpdateRuleset,
		iD,
		status,
		rulesetData,
		ruleCount,
		description,
		tags,
		metadata,
		updatedBy,
	)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const UpdateRulesetStatus = `-- name: UpdateRulesetStatus :one
UPDATE rulesets 
SET 
    status = $2,
    updated_by = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by
`

func (q *Queries) UpdateRulesetStatus(ctx context.Context, iD uuid.UUID, status RulesetStatus, updatedBy pgtype.Text) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, UpdateRulesetStatus, iD, status, updatedBy)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}

const UpsertRuleset = `-- name: UpsertRuleset :one
INSERT INTO rulesets (
    name, version, environment, status, ruleset_data, rule_count,
    description, tags, owner, team, metadata,
    git_commit, git_branch, git_tag, git_author, pull_request,
    compiled_at, compiler_version, schema_version, validation_hash,
    created_by, updated_by
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14, $15, $16,
    $17, $18, $19, $20,
    $21, $22
)
ON CONFLICT (name, version, environment) 
DO UPDATE SET
    status = EXCLUDED.status,
    ruleset_data = EXCLUDED.ruleset_data,
    rule_count = EXCLUDED.rule_count,
    description = EXCLUDED.description,
    tags = EXCLUDED.tags,
    metadata = EXCLUDED.metadata,
    git_commit = EXCLUDED.git_commit,
    git_branch = EXCLUDED.git_branch,
    git_tag = EXCLUDED.git_tag,
    git_author = EXCLUDED.git_author,
    pull_request = EXCLUDED.pull_request,
    compiled_at = EXCLUDED.compiled_at,
    compiler_version = EXCLUDED.compiler_version,
    schema_version = EXCLUDED.schema_version,
    validation_hash = EXCLUDED.validation_hash,
    updated_by = EXCLUDED.updated_by,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, name, version, environment, status, ruleset_data, rule_count, description, tags, owner, team, metadata, git_commit, git_branch, git_tag, git_author, pull_request, compiled_at, compiler_version, schema_version, validation_hash, created_at, updated_at, created_by, updated_by
`

func (q *Queries) UpsertRuleset(ctx context.Context, name string, version string, environment string, status RulesetStatus, rulesetData json.RawMessage, ruleCount int32, description pgtype.Text, tags []string, owner pgtype.Text, team pgtype.Text, metadata json.RawMessage, gitCommit pgtype.Text, gitBranch pgtype.Text, gitTag pgtype.Text, gitAuthor pgtype.Text, pullRequest pgtype.Text, compiledAt pgtype.Timestamptz, compilerVersion pgtype.Text, schemaVersion pgtype.Text, validationHash pgtype.Text, createdBy pgtype.Text, updatedBy pgtype.Text) (*Ruleset, error) {
	row := q.db.QueryRow(ctx, UpsertRuleset,
		name,
		version,
		environment,
		status,
		rulesetData,
		ruleCount,
		description,
		tags,
		owner,
		team,
		metadata,
		gitCommit,
		gitBranch,
		gitTag,
		gitAuthor,
		pullRequest,
		compiledAt,
		compilerVersion,
		schemaVersion,
		validationHash,
		createdBy,
		updatedBy,
	)
	var i Ruleset
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Version,
		&i.Environment,
		&i.Status,
		&i.RulesetData,
		&i.RuleCount,
		&i.Description,
		&i.Tags,
		&i.Owner,
		&i.Team,
		&i.Metadata,
		&i.GitCommit,
		&i.GitBranch,
		&i.GitTag,
		&i.GitAuthor,
		&i.PullRequest,
		&i.CompiledAt,
		&i.CompilerVersion,
		&i.SchemaVersion,
		&i.ValidationHash,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return &i, err
}
