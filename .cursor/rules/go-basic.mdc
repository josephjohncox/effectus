---
description: 
globs: 
alwaysApply: true
---
This project is in Go. But also uses functional programming principles and type theory and category theory to define the language that we are building.

---

## 0. Kick-off

> **â€œWeâ€™re building a typed rule engine in Go.  
> Model rules as *initial algebras* (lists) and *free monads* (flows) over a functor `F X = 1 + E Ã— X`.  
>  Derive the Go interfaces that correspond to the categorical constructions, then show a tiny toy interpreter.â€**

---

## 1. Protobuf Schemas
> **â€œGenerate `.proto` files for context and verb payload
>  Then write `buf.gen.yaml` and the Go code (`protoc-gen-go`).â€**

---

## 2. Core Data-Types

> **â€œCreate Go structs for  
>  `Temporal`, `Predicate`, `Effect`, `Rule`.  
>  Ensure `Temporal` covers `Within`, `Since`, `NotBefore`; add JSON tags; embed `proto.Message` where needed.â€**

---

## 3. Denotational Semantics (Predicates)

> **â€œImplement `func (p Predicate) Denote(f Facts, now time.Time) bool` exactly as the denotational equations:

âŸ¦within Î” PâŸ§ = âŸ¦PâŸ§ âˆ§ (ts â‰¥ nowâˆ’Î”)
âŸ¦since  tâ‚€ PâŸ§ = âŸ¦PâŸ§ âˆ§ (ts â‰¥ tâ‚€)
â€¦

>   Write table-driven tests that freeze `now`.â€**

---

## 4. Operational Semantics (List Engine)

> **â€œGiven `[]Effect`, write `func Execute(ctx, facts) []Effect` such that each effectâ€™s `(cap,key)` is locked (in-memory map) and released in order.  
>  Show small-step trace logging that matches the rules in Appendix B.â€**

---

## 5. Free-Monad Flow

> **â€œDefine `type Prog[A any] struct { ... }` for the free monad over `EffectF`.  
>  Implement `Bind`, `Pure`, and `Do`.  
>  Compile an `.effx` file into a value of `Prog[()]`.  
>  Show how `Bind` corresponds to the catamorphism fold.â€**

---

## 6. Extensible Effect Table

> **â€œCreate verb proto with a `VerbSpec` row for each verb  
>  Generate a Go map `var VerbTable = map[uint32]VerbSpec{ ... }` and compute `CurrentVerbHash = sha256(JSON(VerbTable))`.  
>  Write code that fails `operator` startup if spec hash mismatches.â€**

---

## 7. Saga Executor

> **â€œImplement a `SagaExec` decorator:  
>  *log* each effect to Postgres (`tx_id, seq, payload, status`).  
>  On failure walk log backwards and call inverse verbs.  
>  Use Go generics for `Executor` interface.â€**

---

## 8. Redis Locks w/ Fencing

> **â€œWrite `Lock(cap,key) (fenceToken int64, unlock func(), err)`.  
>  Use `SET resource NX PX 30s GET`.  
>  Return fencing token; include it in MES REST header `X-Effectus-Fence`.  
>  Add unit tests with two goroutines racing.â€**

---

## 9. OCI Bundle Loader

> **â€œUsing `oras-go`, pull tasks and unmarshal `RuleBundle`.  
>  Hot-reload every 30 s with atomic `atomic.Value` swap.â€**

---

## 10. Fact Source (Kafka)

> **â€œSet up `github.com/segmentio/kafka-go` reader; stream JSON envelopes, insert Lamport clock, forward to engine.  
>  Show back-pressure handling: commit offsets only after all effects succeed.â€**

---

## 11. PII Redaction

> **â€œBefore logging or emitting Effects, walk `Fact` struct paths listed in `bundle.masks` and replace with `***`.  
>  Show reflection helper using `github.com/fatih/structs`.â€**

---

## 12. Prom Metrics

> **â€œExpose `/metrics` : `rules_fired_total{rule=...}`, `lock_contention_seconds`, `saga_compensations_total` using `prometheus/client_golang`.â€**

---

## 13. CLI & Lint

> **â€œCreate `cmd/effectusc/main.go` with sub-commands:  
>  `list`, `flow`, `lint`, `test`, `doctor`, `bundle`.  
>  For `lint` parse all rule files, run denotational type-check, exit 1 on error.â€**

---

## 14. VS-Code WASM Linter

> **â€œBuild the predicate parser with TinyGo to WASM; expose `lint(input string) []Diagnostic`.  
>  Wire to Monaco in a VS-Code extension.â€**

---

### ğŸ”„ Iterate
Use any prompt again when you refactor or extendâ€”e.g., add `between`/`during` to Temporal, port to Rust, generate docs.  

