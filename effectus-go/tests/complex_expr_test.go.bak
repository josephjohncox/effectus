package tests

import (
	"testing"

	"github.com/effectus/effectus-go"
	"github.com/effectus/effectus-go/compiler"
	"github.com/effectus/effectus-go/schema/types"
	"github.com/stretchr/testify/assert"
)

// TestComplexExpressionParsing tests parsing and type checking of complex expressions
func TestComplexExpressionParsing(t *testing.T) {
	// Create a type system with known fact paths
	typeSystem := createComplexTestTypeSystem()

	// Create test facts provider using our type system
	facts := createComplexTestFacts(typeSystem)

	// Test cases with complex expressions
	testCases := []struct {
		name        string
		ruleContent string
		shouldPass  bool
		errorMsg    string
	}{
		// Nested boolean operations
		{
			name: "nested_boolean_operations",
			ruleContent: `
				rule "NestedBooleans" priority 10 {
					when {
						(customer.premium == true && (customer.balance > 1000.0 || customer.loyalty_years > 5)) && customer.status == "active"
					}
					then {
						ApplyDiscount(percent: 20.0)
					}
				}
			`,
			shouldPass: true,
		},
		// Multiple conditions with different operators
		{
			name: "multiple_comparison_operators",
			ruleContent: `
				rule "MultipleComparisons" priority 10 {
					when {
						customer.balance >= 500.0 && customer.credit_score > 700 && customer.status != "inactive" && customer.risk_level < 3
					}
					then {
						ApproveApplication(reason: "Good standing")
					}
				}
			`,
			shouldPass: true,
		},
		// Complex nested paths
		{
			name: "complex_nested_paths",
			ruleContent: `
				rule "ComplexPaths" priority 10 {
					when {
						order.shipping.address.country == "USA" && order.items_count > 5 && order.customer.premium == true
					}
					then {
						OfferFreeShipping(order_id: order.id)
					}
				}
			`,
			shouldPass: true,
		},
		// Array access and indexing
		{
			name: "array_access_operations",
			ruleContent: `
				rule "ArrayAccess" priority 10 {
					when {
						order.items[0].quantity > 3 && order.items[0].price > 50.0
					}
					then {
						AddBundleDiscount(order_id: order.id, discount: 15.0)
					}
				}
			`,
			shouldPass: true,
		},
		// Combined complex conditions
		{
			name: "combined_complex_conditions",
			ruleContent: `
				rule "ComplexConditions" priority 10 {
					when {
						(customer.premium == true || customer.loyalty_years > 3) && 
						(order.total > 200.0 || order.items_count >= 4) && 
						!(order.shipping.express == true && customer.balance < 50.0)
					}
					then {
						ApplyPromotion(code: "LOYALTY", description: "Loyalty promotion")
					}
				}
			`,
			shouldPass: true,
		},
		// Type mismatch in complex expression
		{
			name: "type_mismatch_in_complex",
			ruleContent: `
				rule "TypeMismatchComplex" priority 10 {
					when {
						customer.premium == "true"  // Type mismatch: customer.premium is a boolean
					}
					then {
						NotifyError(message: "Type mismatch detected")
					}
				}
			`,
			shouldPass: false,
			errorMsg:   "not compatible with",
		},
		// Unknown path in complex expression
		{
			name: "unknown_path_in_complex",
			ruleContent: `
				rule "UnknownPathComplex" priority 10 {
					when {
						customer.premium == true && customer.unknown_field > 10  // Unknown field
					}
					then {
						NotifyError(message: "Unknown field detected")
					}
				}
			`,
			shouldPass: false,
			errorMsg:   "fact path does not exist",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create a compiler with our test type system
			comp := compiler.NewCompiler()

			// Get the compiler's type system and replace it with our test type system
			compTS := comp.GetTypeSystem()

			// Copy our test type system's fact types to the compiler's type system
			for _, path := range typeSystem.GetAllFactPaths() {
				factType, _ := typeSystem.GetFactType(path)
				compTS.RegisterFactType(path, factType)
			}

			// Register test verbs
			compTS.RegisterVerbType("ApplyDiscount",
				map[string]*types.Type{"percent": types.NewFloatType()},
				types.NewBoolType())

			compTS.RegisterVerbType("ApproveApplication",
				map[string]*types.Type{"reason": types.NewStringType()},
				types.NewBoolType())

			compTS.RegisterVerbType("OfferFreeShipping",
				map[string]*types.Type{"order_id": types.NewStringType()},
				types.NewBoolType())

			compTS.RegisterVerbType("AddBundleDiscount",
				map[string]*types.Type{
					"order_id": types.NewStringType(),
					"discount": types.NewFloatType(),
				},
				types.NewBoolType())

			compTS.RegisterVerbType("ApplyPromotion",
				map[string]*types.Type{
					"code":        types.NewStringType(),
					"description": types.NewStringType(),
				},
				types.NewBoolType())

			compTS.RegisterVerbType("NotifyError",
				map[string]*types.Type{"message": types.NewStringType()},
				types.NewBoolType())

			// Write the rule to a temporary file
			tmpFile := createTempRuleFile(t, tc.ruleContent)
			defer cleanupTempFile(tmpFile)

			// Attempt to parse and type check
			_, err := comp.ParseAndTypeCheck(tmpFile, facts)

			if tc.shouldPass {
				assert.NoError(t, err, "Expected complex expression parsing to pass")
			} else {
				assert.Error(t, err, "Expected complex expression parsing to fail")
				if tc.errorMsg != "" {
					assert.Contains(t, err.Error(), tc.errorMsg, "Error should contain expected message")
				}
			}
		})
	}
}

// createComplexTestTypeSystem creates a type system with predefined fact paths for testing complex expressions
func createComplexTestTypeSystem() *types.TypeSystem {
	ts := types.NewTypeSystem()

	// Create customer type with multiple fields
	customerType := types.NewObjectType()
	customerType.AddProperty("id", types.NewStringType())
	customerType.AddProperty("name", types.NewStringType())
	customerType.AddProperty("status", types.NewStringType())
	customerType.AddProperty("balance", types.NewFloatType())
	customerType.AddProperty("premium", types.NewBoolType())
	customerType.AddProperty("loyalty_years", types.NewIntType())
	customerType.AddProperty("credit_score", types.NewIntType())
	customerType.AddProperty("risk_level", types.NewIntType())

	// Create address type
	addressType := types.NewObjectType()
	addressType.AddProperty("street", types.NewStringType())
	addressType.AddProperty("city", types.NewStringType())
	addressType.AddProperty("state", types.NewStringType())
	addressType.AddProperty("country", types.NewStringType())
	addressType.AddProperty("zip", types.NewStringType())

	// Create shipping type
	shippingType := types.NewObjectType()
	shippingType.AddProperty("method", types.NewStringType())
	shippingType.AddProperty("cost", types.NewFloatType())
	shippingType.AddProperty("express", types.NewBoolType())
	shippingType.AddProperty("address", addressType)

	// Create order item type
	orderItemType := types.NewObjectType()
	orderItemType.AddProperty("id", types.NewStringType())
	orderItemType.AddProperty("name", types.NewStringType())
	orderItemType.AddProperty("price", types.NewFloatType())
	orderItemType.AddProperty("quantity", types.NewIntType())
	orderItemType.AddProperty("taxable", types.NewBoolType())

	// Create order items array type
	itemsArrayType := types.NewListType(orderItemType)

	// Create order type
	orderType := types.NewObjectType()
	orderType.AddProperty("id", types.NewStringType())
	orderType.AddProperty("date", types.NewStringType())
	orderType.AddProperty("total", types.NewFloatType())
	orderType.AddProperty("tax", types.NewFloatType())
	orderType.AddProperty("items_count", types.NewIntType())
	orderType.AddProperty("items", itemsArrayType)
	orderType.AddProperty("shipping", shippingType)
	orderType.AddProperty("customer", customerType) // Nested customer reference

	// Register parent objects
	ts.RegisterFactType("customer", customerType)
	ts.RegisterFactType("order", orderType)

	// Register all customer path variations
	ts.RegisterFactType("customer.id", types.NewStringType())
	ts.RegisterFactType("customer.name", types.NewStringType())
	ts.RegisterFactType("customer.status", types.NewStringType())
	ts.RegisterFactType("customer.balance", types.NewFloatType())
	ts.RegisterFactType("customer.premium", types.NewBoolType())
	ts.RegisterFactType("customer.loyalty_years", types.NewIntType())
	ts.RegisterFactType("customer.credit_score", types.NewIntType())
	ts.RegisterFactType("customer.risk_level", types.NewIntType())

	// Register all order path variations
	ts.RegisterFactType("order.id", types.NewStringType())
	ts.RegisterFactType("order.date", types.NewStringType())
	ts.RegisterFactType("order.total", types.NewFloatType())
	ts.RegisterFactType("order.tax", types.NewFloatType())
	ts.RegisterFactType("order.items_count", types.NewIntType())
	ts.RegisterFactType("order.items", itemsArrayType)
	ts.RegisterFactType("order.items.length", types.NewIntType())
	ts.RegisterFactType("order.items[0]", orderItemType)
	ts.RegisterFactType("order.items[0].id", types.NewStringType())
	ts.RegisterFactType("order.items[0].name", types.NewStringType())
	ts.RegisterFactType("order.items[0].price", types.NewFloatType())
	ts.RegisterFactType("order.items[0].quantity", types.NewIntType())
	ts.RegisterFactType("order.items[0].taxable", types.NewBoolType())

	// Register shipping paths
	ts.RegisterFactType("order.shipping", shippingType)
	ts.RegisterFactType("order.shipping.method", types.NewStringType())
	ts.RegisterFactType("order.shipping.cost", types.NewFloatType())
	ts.RegisterFactType("order.shipping.express", types.NewBoolType())
	ts.RegisterFactType("order.shipping.address", addressType)
	ts.RegisterFactType("order.shipping.address.street", types.NewStringType())
	ts.RegisterFactType("order.shipping.address.city", types.NewStringType())
	ts.RegisterFactType("order.shipping.address.state", types.NewStringType())
	ts.RegisterFactType("order.shipping.address.country", types.NewStringType())
	ts.RegisterFactType("order.shipping.address.zip", types.NewStringType())

	// Register nested customer reference
	ts.RegisterFactType("order.customer", customerType)
	ts.RegisterFactType("order.customer.id", types.NewStringType())
	ts.RegisterFactType("order.customer.premium", types.NewBoolType())

	return ts
}

// ComplexTestFactSchema implements the SchemaInfo interface for testing complex expressions
type ComplexTestFactSchema struct {
	typeSystem *types.TypeSystem
}

func (s *ComplexTestFactSchema) ValidatePath(path string) bool {
	// Handle parent paths
	if path == "customer" || path == "order" {
		return true
	}

	// Handle array access paths
	if path == "order.items" || path == "order.items[0]" {
		return true
	}

	// Handle common array/collection property
	if path == "order.items.length" {
		return true
	}

	// Handle nested paths
	if path == "order.shipping" || path == "order.shipping.address" || path == "order.customer" {
		return true
	}

	// Check with type system
	_, err := s.typeSystem.GetFactType(path)
	return err == nil
}

// ComplexTestFacts implements the Facts interface for testing complex expressions
type ComplexTestFacts struct {
	data   map[string]interface{}
	schema effectus.SchemaInfo
}

func (f *ComplexTestFacts) Get(path string) (interface{}, bool) {
	// Special handling for parent paths
	if path == "customer" {
		return map[string]interface{}{
			"id":            "CUST-123",
			"name":          "John Doe",
			"status":        "active",
			"balance":       1250.75,
			"premium":       true,
			"loyalty_years": 7,
			"credit_score":  750,
			"risk_level":    2,
		}, true
	}

	if path == "order" {
		return map[string]interface{}{
			"id":          "ORD-456",
			"date":        "2023-04-15",
			"total":       325.50,
			"tax":         32.55,
			"items_count": 3,
			"items": []map[string]interface{}{
				{
					"id":       "ITEM-1",
					"name":     "Premium Widget",
					"price":    99.99,
					"quantity": 2,
					"taxable":  true,
				},
				{
					"id":       "ITEM-2",
					"name":     "Basic Widget",
					"price":    49.99,
					"quantity": 1,
					"taxable":  true,
				},
			},
			"shipping": map[string]interface{}{
				"method":  "standard",
				"cost":    12.99,
				"express": false,
				"address": map[string]interface{}{
					"street":  "123 Main St",
					"city":    "Anytown",
					"state":   "CA",
					"country": "USA",
					"zip":     "90210",
				},
			},
			"customer": map[string]interface{}{
				"id":      "CUST-123",
				"premium": true,
			},
		}, true
	}

	// Handle array access
	if path == "order.items[0]" {
		return map[string]interface{}{
			"id":       "ITEM-1",
			"name":     "Premium Widget",
			"price":    99.99,
			"quantity": 4,
			"taxable":  true,
		}, true
	}

	if path == "order.items.length" {
		return 2, true
	}

	// Handle nested paths
	if path == "order.shipping" {
		return map[string]interface{}{
			"method":  "standard",
			"cost":    12.99,
			"express": false,
			"address": map[string]interface{}{
				"street":  "123 Main St",
				"city":    "Anytown",
				"state":   "CA",
				"country": "USA",
				"zip":     "90210",
			},
		}, true
	}

	if path == "order.shipping.address" {
		return map[string]interface{}{
			"street":  "123 Main St",
			"city":    "Anytown",
			"state":   "CA",
			"country": "USA",
			"zip":     "90210",
		}, true
	}

	if path == "order.customer" {
		return map[string]interface{}{
			"id":      "CUST-123",
			"premium": true,
		}, true
	}

	// Handle deep-nested property access
	if path == "order.items[0].price" {
		return 99.99, true
	}

	if path == "order.items[0].quantity" {
		return 4, true
	}

	if path == "order.shipping.express" {
		return false, true
	}

	if path == "order.shipping.address.country" {
		return "USA", true
	}

	if path == "order.customer.premium" {
		return true, true
	}

	// Fall back to the predefined map
	val, exists := f.data[path]
	return val, exists
}

func (f *ComplexTestFacts) Schema() effectus.SchemaInfo {
	return f.schema
}

// createComplexTestFacts creates a test facts provider for complex expression testing
func createComplexTestFacts(ts *types.TypeSystem) *ComplexTestFacts {
	schema := &ComplexTestFactSchema{typeSystem: ts}

	// Create sample facts
	data := map[string]interface{}{
		"customer.id":            "CUST-123",
		"customer.name":          "John Doe",
		"customer.status":        "active",
		"customer.balance":       1250.75,
		"customer.premium":       true,
		"customer.loyalty_years": 7,
		"customer.credit_score":  750,
		"customer.risk_level":    2,

		"order.id":          "ORD-456",
		"order.date":        "2023-04-15",
		"order.total":       325.50,
		"order.tax":         32.55,
		"order.items_count": 3,

		"order.shipping.method":          "standard",
		"order.shipping.cost":            12.99,
		"order.shipping.express":         false,
		"order.shipping.address.street":  "123 Main St",
		"order.shipping.address.city":    "Anytown",
		"order.shipping.address.state":   "CA",
		"order.shipping.address.country": "USA",
		"order.shipping.address.zip":     "90210",

		"order.customer.id":      "CUST-123",
		"order.customer.premium": true,
	}

	return &ComplexTestFacts{
		data:   data,
		schema: schema,
	}
}
