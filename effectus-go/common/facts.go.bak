package common

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/effectus/effectus-go/schema/types"
	"github.com/tidwall/gjson"
)

// Path is a type alias for string to maintain backward compatibility
type Path = string

// ResolutionResult provides information about path resolution
type ResolutionResult struct {
	Path   Path
	Value  interface{}
	Exists bool
	Error  error
	Type   *types.Type
}

// SchemaInfo provides metadata about the fact schema
type SchemaInfo interface {
	// ValidatePath checks if a path is valid according to the schema
	ValidatePath(path string) bool

	// GetPathType returns the type for a path (optional)
	GetPathType(path string) *types.Type
}

// Facts provides a standard interface for accessing data by path
type Facts interface {
	// Get retrieves a value by path
	Get(path string) (interface{}, bool)

	// GetWithContext retrieves a value with resolution info
	GetWithContext(path string) (interface{}, *ResolutionResult)

	// Schema returns schema information
	Schema() SchemaInfo
}

// BasicSchema provides a simple schema implementation
type BasicSchema struct {
	// Type mapping for paths
	typeInfo map[string]*types.Type
}

// NewBasicSchema creates a new basic schema
func NewBasicSchema() *BasicSchema {
	return &BasicSchema{
		typeInfo: make(map[string]*types.Type),
	}
}

// ValidatePath validates a path
func (s *BasicSchema) ValidatePath(path string) bool {
	// Basic schema validates all non-empty paths
	return path != ""
}

// GetPathType implements SchemaInfo interface
func (s *BasicSchema) GetPathType(path string) *types.Type {
	if s.typeInfo == nil {
		return nil
	}
	return s.typeInfo[path]
}

// RegisterPathType implements SchemaInfo interface
func (s *BasicSchema) RegisterPathType(path string, typ *types.Type) {
	if s.typeInfo == nil {
		s.typeInfo = make(map[string]*types.Type)
	}
	s.typeInfo[path] = typ
}

// FactsExt extends the Facts interface with structured path methods
type FactsExt interface {
	Facts

	// GetByPath gets a value by structured path (deprecated)
	GetByPath(path string) (interface{}, bool)
}

// BasicFacts provides an immutable facts implementation using gjson
type BasicFacts struct {
	rawJSON string
	schema  SchemaInfo
}

// NewBasicFacts creates a new facts instance from data and schema
func NewBasicFacts(data map[string]interface{}, schema SchemaInfo) *BasicFacts {
	if schema == nil {
		schema = NewBasicSchema()
	}

	// Convert data to JSON
	jsonBytes, err := json.Marshal(data)
	if err != nil {
		panic(fmt.Sprintf("failed to marshal data: %v", err))
	}

	return &BasicFacts{
		rawJSON: string(jsonBytes),
		schema:  schema,
	}
}

// Get implements Facts interface
func (f *BasicFacts) Get(path string) (interface{}, bool) {
	result, info := f.GetWithContext(path)
	return result, info != nil && info.Exists
}

// GetWithContext implements Facts interface
func (f *BasicFacts) GetWithContext(path string) (interface{}, *ResolutionResult) {
	if f.rawJSON == "" {
		return nil, &ResolutionResult{
			Exists: false,
			Error:  errors.New("no data"),
			Path:   path,
		}
	}

	if path == "" {
		return nil, &ResolutionResult{
			Exists: false,
			Error:  errors.New("empty path"),
			Path:   path,
		}
	}

	// Use gjson to resolve the path
	result := gjson.Get(f.rawJSON, path)

	if !result.Exists() {
		return nil, &ResolutionResult{
			Path:   path,
			Exists: false,
			Error:  fmt.Errorf("path not found: %s", path),
		}
	}

	// Convert gjson result to Go value
	value := gjsonResultToInterface(result)

	// Get the type for this path
	pathType := f.schema.GetPathType(path)

	return value, &ResolutionResult{
		Path:   path,
		Value:  value,
		Exists: true,
		Type:   pathType,
	}
}

// GetByPath implements FactsExt interface for backward compatibility
func (f *BasicFacts) GetByPath(path string) (interface{}, bool) {
	return f.Get(path)
}

// Schema implements Facts interface
func (f *BasicFacts) Schema() SchemaInfo {
	return f.schema
}

// HasPath checks if a path exists in the facts
func (f *BasicFacts) HasPath(path string) bool {
	_, exists := f.Get(path)
	return exists
}

// WithData creates a new Facts instance with updated data
func (f *BasicFacts) WithData(updatedData map[string]interface{}) *BasicFacts {
	return NewBasicFacts(updatedData, f.schema)
}

// Helper to convert gjson.Result to interface{}
func gjsonResultToInterface(result gjson.Result) interface{} {
	switch result.Type {
	case gjson.Null:
		return nil
	case gjson.False:
		return false
	case gjson.True:
		return true
	case gjson.Number:
		if result.Float() == float64(result.Int()) {
			return result.Int()
		}
		return result.Float()
	case gjson.String:
		return result.String()
	case gjson.JSON:
		if result.IsArray() {
			arr := result.Array()
			interfaceArray := make([]interface{}, len(arr))
			for i, v := range arr {
				interfaceArray[i] = gjsonResultToInterface(v)
			}
			return interfaceArray
		} else {
			m := result.Map()
			interfaceMap := make(map[string]interface{})
			for k, v := range m {
				interfaceMap[k] = gjsonResultToInterface(v)
			}
			return interfaceMap
		}
	default:
		return nil
	}
}
