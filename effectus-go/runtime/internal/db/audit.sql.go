// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit.sql

package db

import (
	"context"
	"encoding/json"
	"net"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CleanupOldAuditLogs = `-- name: CleanupOldAuditLogs :exec
DELETE FROM audit_log
WHERE timestamp < $1
`

func (q *Queries) CleanupOldAuditLogs(ctx context.Context, timestamp pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, CleanupOldAuditLogs, timestamp)
	return err
}

const CreateAuditEntry = `-- name: CreateAuditEntry :one

INSERT INTO audit_log (
    action, resource, resource_id, version, environment,
    user_id, user_email, ip_address, user_agent, session_id,
    details, request_id, trace_id,
    result, error_message, duration_ms
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10,
    $11, $12, $13,
    $14, $15, $16
) RETURNING id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition
`

// Audit log queries for sqlc code generation
func (q *Queries) CreateAuditEntry(ctx context.Context, action string, resource string, resourceID uuid.UUID, version pgtype.Text, environment pgtype.Text, userID pgtype.Text, userEmail pgtype.Text, ipAddress net.IP, userAgent pgtype.Text, sessionID pgtype.Text, details json.RawMessage, requestID pgtype.Text, traceID pgtype.Text, result string, errorMessage pgtype.Text, durationMs pgtype.Int4) (*AuditLog, error) {
	row := q.db.QueryRow(ctx, CreateAuditEntry,
		action,
		resource,
		resourceID,
		version,
		environment,
		userID,
		userEmail,
		ipAddress,
		userAgent,
		sessionID,
		details,
		requestID,
		traceID,
		result,
		errorMessage,
		durationMs,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.Resource,
		&i.ResourceID,
		&i.Version,
		&i.Environment,
		&i.UserID,
		&i.UserEmail,
		&i.IpAddress,
		&i.UserAgent,
		&i.SessionID,
		&i.Details,
		&i.RequestID,
		&i.TraceID,
		&i.Result,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.Timestamp,
		&i.MonthPartition,
	)
	return &i, err
}

const GetAuditLogs = `-- name: GetAuditLogs :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE 
    ($1::text[] IS NULL OR action = ANY($1::text[]))
    AND ($2::text[] IS NULL OR resource = ANY($2::text[]))
    AND ($3::text[] IS NULL OR user_id = ANY($3::text[]))
    AND ($4::timestamptz IS NULL OR timestamp >= $4)
    AND ($5::timestamptz IS NULL OR timestamp <= $5)
    AND ($6::text IS NULL OR result = $6)
    AND ($7::text IS NULL OR environment = $7)
ORDER BY timestamp DESC
LIMIT $8 OFFSET $9
`

func (q *Queries) GetAuditLogs(ctx context.Context, column1 []string, column2 []string, column3 []string, column4 pgtype.Timestamptz, column5 pgtype.Timestamptz, column6 string, column7 string, limit int32, offset int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogs,
		column1,
		column2,
		column3,
		column4,
		column5,
		column6,
		column7,
		limit,
		offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByResource = `-- name: GetAuditLogsByResource :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE resource = $1 AND ($2::text IS NULL OR version = $2)
ORDER BY timestamp DESC
LIMIT $3
`

func (q *Queries) GetAuditLogsByResource(ctx context.Context, resource string, column2 string, limit int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByResource, resource, column2, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsBySession = `-- name: GetAuditLogsBySession :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE session_id = $1
ORDER BY timestamp ASC
`

func (q *Queries) GetAuditLogsBySession(ctx context.Context, sessionID pgtype.Text) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByTrace = `-- name: GetAuditLogsByTrace :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE trace_id = $1
ORDER BY timestamp ASC
`

func (q *Queries) GetAuditLogsByTrace(ctx context.Context, traceID pgtype.Text) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByTrace, traceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByUser = `-- name: GetAuditLogsByUser :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE user_id = $1 AND timestamp >= $2
ORDER BY timestamp DESC
LIMIT $3
`

func (q *Queries) GetAuditLogsByUser(ctx context.Context, userID pgtype.Text, timestamp pgtype.Timestamptz, limit int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByUser, userID, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditStats = `-- name: GetAuditStats :one
SELECT 
    COUNT(*) as total_entries,
    COUNT(*) FILTER (WHERE result = 'success') as successful_operations,
    COUNT(*) FILTER (WHERE result = 'failure') as failed_operations,
    COUNT(DISTINCT user_id) as unique_users,
    COUNT(DISTINCT action) as unique_actions,
    AVG(duration_ms) FILTER (WHERE duration_ms IS NOT NULL) as avg_duration_ms
FROM audit_log
WHERE timestamp >= $1
`

type GetAuditStatsRow struct {
	TotalEntries         int64   `db:"total_entries" json:"total_entries"`
	SuccessfulOperations int64   `db:"successful_operations" json:"successful_operations"`
	FailedOperations     int64   `db:"failed_operations" json:"failed_operations"`
	UniqueUsers          int64   `db:"unique_users" json:"unique_users"`
	UniqueActions        int64   `db:"unique_actions" json:"unique_actions"`
	AvgDurationMs        float64 `db:"avg_duration_ms" json:"avg_duration_ms"`
}

func (q *Queries) GetAuditStats(ctx context.Context, timestamp pgtype.Timestamptz) (*GetAuditStatsRow, error) {
	row := q.db.QueryRow(ctx, GetAuditStats, timestamp)
	var i GetAuditStatsRow
	err := row.Scan(
		&i.TotalEntries,
		&i.SuccessfulOperations,
		&i.FailedOperations,
		&i.UniqueUsers,
		&i.UniqueActions,
		&i.AvgDurationMs,
	)
	return &i, err
}

const GetFailedOperations = `-- name: GetFailedOperations :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE result = 'failure' AND timestamp >= $1
ORDER BY timestamp DESC
LIMIT $2
`

func (q *Queries) GetFailedOperations(ctx context.Context, timestamp pgtype.Timestamptz, limit int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetFailedOperations, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecentErrorsCount = `-- name: GetRecentErrorsCount :one
SELECT COUNT(*) as error_count
FROM audit_log
WHERE result = 'failure' AND timestamp >= $1
`

func (q *Queries) GetRecentErrorsCount(ctx context.Context, timestamp pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, GetRecentErrorsCount, timestamp)
	var error_count int64
	err := row.Scan(&error_count)
	return error_count, err
}

const GetSecurityEvents = `-- name: GetSecurityEvents :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE 
    (action LIKE '%login%' OR action LIKE '%auth%' OR action LIKE '%security%')
    AND timestamp >= $1
ORDER BY timestamp DESC
LIMIT $2
`

func (q *Queries) GetSecurityEvents(ctx context.Context, timestamp pgtype.Timestamptz, limit int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, GetSecurityEvents, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTopActions = `-- name: GetTopActions :many
SELECT action, COUNT(*) as count
FROM audit_log
WHERE timestamp >= $1
GROUP BY action
ORDER BY count DESC
LIMIT $2
`

type GetTopActionsRow struct {
	Action string `db:"action" json:"action"`
	Count  int64  `db:"count" json:"count"`
}

func (q *Queries) GetTopActions(ctx context.Context, timestamp pgtype.Timestamptz, limit int32) ([]*GetTopActionsRow, error) {
	rows, err := q.db.Query(ctx, GetTopActions, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopActionsRow{}
	for rows.Next() {
		var i GetTopActionsRow
		if err := rows.Scan(&i.Action, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTopUsers = `-- name: GetTopUsers :many
SELECT user_id, user_email, COUNT(*) as action_count
FROM audit_log
WHERE timestamp >= $1
GROUP BY user_id, user_email
ORDER BY action_count DESC
LIMIT $2
`

type GetTopUsersRow struct {
	UserID      pgtype.Text `db:"user_id" json:"user_id"`
	UserEmail   pgtype.Text `db:"user_email" json:"user_email"`
	ActionCount int64       `db:"action_count" json:"action_count"`
}

func (q *Queries) GetTopUsers(ctx context.Context, timestamp pgtype.Timestamptz, limit int32) ([]*GetTopUsersRow, error) {
	rows, err := q.db.Query(ctx, GetTopUsers, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTopUsersRow{}
	for rows.Next() {
		var i GetTopUsersRow
		if err := rows.Scan(&i.UserID, &i.UserEmail, &i.ActionCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchAuditLogs = `-- name: SearchAuditLogs :many
SELECT id, action, resource, resource_id, version, environment, user_id, user_email, ip_address, user_agent, session_id, details, request_id, trace_id, result, error_message, duration_ms, timestamp, month_partition FROM audit_log
WHERE 
    (to_tsvector('english', action || ' ' || resource || ' ' || COALESCE(user_email, '')) @@ plainto_tsquery($1))
    AND timestamp >= $2
ORDER BY timestamp DESC
LIMIT $3
`

func (q *Queries) SearchAuditLogs(ctx context.Context, plaintoTsquery string, timestamp pgtype.Timestamptz, limit int32) ([]*AuditLog, error) {
	rows, err := q.db.Query(ctx, SearchAuditLogs, plaintoTsquery, timestamp, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Resource,
			&i.ResourceID,
			&i.Version,
			&i.Environment,
			&i.UserID,
			&i.UserEmail,
			&i.IpAddress,
			&i.UserAgent,
			&i.SessionID,
			&i.Details,
			&i.RequestID,
			&i.TraceID,
			&i.Result,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Timestamp,
			&i.MonthPartition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
